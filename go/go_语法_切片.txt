make创建：
// 创建一个整型切片
// 其长度和容量都是 5 个元素
slice := make([]int, 5)

// 创建一个整型切片
// 其长度为 3 个元素，容量为 5 个元素
slice := make([]int, 3, 5)

-----------------------

b10 := []byte("int (base 10):") //"int (base 10):"不是第一个元素内容

-------------------

创建：
// 创建字符串切片
// 其长度和容量都是 3 个元素
myStr := []string{"Jack", "Mark", "Nick"}       //{}是元素内容

// 创建一个整型切片
// 其长度和容量都是 4 个元素
myNum := []int{10, 20, 30, 40}

// 创建字符串切片
// 使用空字符串初始化第 100 个元素
myStr := []string{99: ""}

----------------------

空切片：
// 使用 make 创建空的整型切片
myNum := make([]int, 0)
// 使用切片字面量创建空的整型切片
myNum := []int{}

---------------

赋值：
// 创建一个整型切片
// 其容量和长度都是 5 个元素
myNum := []int{10, 20, 30, 40, 50}
// 改变索引为 1 的元素的值
myNum [1] = 25

--------

切片之所以被称为切片，是因为创建一个新的切片，也就是把底层数组切出一部分。通过切片创建新切片的语法如下：

slice[i:j]         //没指定容量
slice[i:j:k]    //指定容量，i到k不包含k为容量
其中 i 表示从 slice 的第几个元素开始切，j 控制切片的长度(j-i)，k 控制切片的容量(k-i)，如果没有给定 k，则表示切到底层数组的最尾部。下面是几种常见的简写形式：

slice[i:]  // 从 i 切到最尾部
slice[:j]  // 从最开头切到 j(不包含 j)
slice[:]   // 从头切到尾，等价于复制整个 slice
让我们通过下面的例子来理解通过切片创建新的切片的本质：

// 创建一个整型切片
// 其长度和容量都是 5 个元素
myNum := []int{10, 20, 30, 40, 50}   //[]int 又在{}前面。[]里面没写数字
// 创建一个新切片
// 其长度为 2 个元素，容量为 4 个元素
newNum := slice[1:3]
执行上面的代码后，我们有了两个切片，它们共享同一段底层数组，但通过不同的切片会看到底层数组的不同部分：

如果在创建切片时设置切片的容量和长度一样，就可以强制让新切片的第一个 append 操作创建新的底层数组，与原有的底层数组分离。

--------------------

// 创建两个切片，并分别用两个整数进行初始化
num1 := []int{1, 2}
num2 := []int{3, 4}
// 将两个切片追加在一起，并显示结果
fmt.Printf("%v\n", append(num1, num2...))

----------------

func copy(dst, src []Type) int
它表示把切片 src 中的元素拷贝到切片 dst 中，返回值为拷贝成功的元素个数。如果 src 比 dst 长，就截断；如果 src 比 dst 短，则只拷贝 src 那部分：

num1 := []int{10, 20, 30}
num2 := make([]int, 5)
count := copy(num2, num1)
fmt.Println(count)
fmt.Println(num2)          //打印
运行这段单面，输出的结果为：


3
[10 20 30 0 0]

----------------------------


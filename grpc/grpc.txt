gRpc异步接口只有C++提供 go的grpc每个调用都是一个协程 所以客户端不是一个请求不结束 下一个请求不开始；同理服务端也是每个响应一个协程 你看起来是同步 其实是异步；

只是服务度在处理的时候会访问共享数据 会在临界区上等待 从这个角度上看服务端的处理又是同步的 

一次交互可以4M


--------------------
简单算一个goroutine 2k，一百万才2G

1G =1024M =1024*1024kb=500w* 2kb
2g = 100w*2kb
-------

go 本来就是牺牲性能换取可维护性的。

开发效率高，代码维护性好，rust我不了解，但开发效率，可维护性远比c/c++好。

c的nginx 已经把异步发扬光大

一个就是减少内存，golang开goroutine开销很小，二就是减少gc压力


https://colobu.com/2019/02/23/1m-go-tcp-connection/


------
协成多了cpu在调度上花费很多，目前正在做一个长连接接入服务，一条连接有两个协成分别进行读写，没请求的话单机能抗400w连接，但是实际场景是一条连接维持20s左右，
一条连接平均发1次请求，结果一台机子只能抗住30w连接，qps也才1w多，pprof跑了下，调度占了快一半了。我准备换成这个框架看下效果